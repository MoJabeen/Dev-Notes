% Mo Jabeen Template for docs 

\documentclass[11pt]{scrartcl} % Font size

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{	
	\normalfont\normalsize
	\vspace{20pt} % Whitespace
	{\huge Clean Code by Robert C Martin}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	
	\author{\small Mo D Jabeen} % Your name
	
	\date{\normalsize\today} % Today's date (\today) or a custom date
	
}

	\begin{document}

	\maketitle % Print the title
	
	\section{Variable Names}

	\begin{itemize}
		\item Names should show their intention
		\item Avoid multiple names with small changes between them
		\item Avoid names with other known meanings
		\item Avoid meaningless names like data, var etc
		\item Check if names are pronounceable
		\item The length of the name should correspond to the scope of the var
		
		\item Test good naming scheme has no mental mapping of names
		\item Method names should be verbs
		\item Use known subject domain names
		\item Create names that give context : Classes are great way to link context
	\end{itemize}

\section{Functions}

	\begin{itemize}

		\item Keep functions very small, should be < 20 lines long
		\item Should \textit{do only one thing} (the name of the function)
		\item Condition statements (if, else, while) should only be one line long; call a function
		\item Keep to one level of abstraction in the function
	\end{itemize}

	\begin{itemize}

		\item Switch statements should be used in a low level class creating new instances instead of jumping to functions
		\begin{itemize}
			\item Use polymorphism to determine the function based on the object
			\item Use design type : ABSTRACT FACTORY
		\end{itemize}  
		
		\item Long names for functions are acceptable
		\item Minimise number of arguments (use structs and objects)
		
		\item There are three forms of functions:
		\begin{itemize}
			\item Questions, getting info about the arg
			\item Operative, transform arg and return it
			\item Event, Trigger change of state based on arg	  
		\end{itemize}
		
		\item  Avoid flag arguments
		\item {A list of related variables can be considered one arg; (meh(int blah, int ...args))}

		\item Function arguments should not be changed in the function (the output should be via return)
		\item Remove any duplication of calling functions !!

	\end{itemize}

\section{Comments}

\begin{itemize}
	\item \textbf{Good comments dont replace bad code !!}
\end{itemize}

\begin{itemize}

	\item Good for showing intent (why you made this decision)
	\item Use comments to add extra clarification on confusing syntax
	\item Show warnings on important areas of code
	\item Can be used with IDEs for Todos
	
	\item Avoid statements that are not completely accurate
	\item Avoid commented banners instead use more effectively organized code.
	
	\item DONT COMMENT OUT CODE, delete it; rely on source control to retrieve old code.
	
\end{itemize}

\section{Formatting}

\begin{itemize}
	\item Small files are preferred
	\item Related concepts should not be in different files
	  - Test: Avoid needing to jump between many files to understand a file
	
	\item Instance variables are placed at the top
	\item Caller functions should be placed above the callee
	\item Dependencies should flow down through the code
	\item Avoid very wide lines of code
	
\end{itemize}

\section{Objects and Data Structures}

Abstraction is all about simplifying and detaching results (details) from an implementation.
\begin{itemize}
	\item Good abstraction allows us to not care about the details of how to interact
	\item Your focus on the abstraction is how to manipulate the essence of data
\end{itemize}

\begin{itemize}
	\item Interfaces give you \textbf{answers/results} not variables and data points.
\end{itemize}

\textbf{Objects:} hide their data behind abstractions and expose functions that operate on that data.
\textbf{Data Structures:} expose their data and have no meaningful functions.\\

Objects are essentially the opposite of data structures, they should facilitate results not be used for compute.
Use procedural code for function based code and objects for data based code.

\begin{itemize}
	\item Procedural code with data structures are good for new functions and bad for new data types
	\item OO code with objects are good for new data types and bad for new functions
\end{itemize}

\subsection{Law of Demeter}

\begin{itemize}
	\item Dont access class variables, its only use should be via internal methods.
	\item Avoid chains of function calls ie meh().hem() etc
	\item Avoid hybrids of OO and procedural; vars should either be freely accessed or encapsulated.
\end{itemize}

\section{Error Handling}

\textbf{Error handling should not be obscure, hidden within functional code.}

\begin{itemize}
	\item Best to scope out errors used in exceptions an not leave them broad.
	\item Good errors allow you to find the issue, they should state the operation that failed and the type of error

	\item Its best practice to wrap any third party APIs for better control and easier to read implementations
	\item Preferable to use SPECIAL CASE class or objects, instead of a null/error that is caught as an exception and dealt with.
\end{itemize}

\section{Unit Testing}

\textbf{TDD} : Tests Driven Development, tests should be written before production code. 
Tests need to be developed with code as, crappy tests or old tests are as good or worse than no tests.

\begin{itemize}
	\item The most important aspect of tests are they are easily readable and 
	therefore easy to maintain
	\item Use the BUILD OPERATE CHECK pattern
	\item Each test function should only test one concept
\end{itemize}

Test should follow FIRST:
\begin{itemize}
	\item Fast (to run)
	\item Independent (not dependant on other tests)
	\item Repeatable
	\item Self Validating (Boolean output - Pass or fail)
	\item Timely (Written before production code)
\end{itemize}

\section{Classes}

\begin{itemize}
	\item Always avoid public variables (accessible from anywhere) in a class
	\item Encapsulation is important to ensure clear separation of concepts
	\item Classes names should define the scope, they should always be small
	
	\item Classes should follow the SRP principle (only have one reason to change)
	\begin{itemize}
		\item To create better abstractions, think about the reasons you would change the class
		\item The methods inside the class should use many of its variables, to create cohesive classes. This is preferred so the class acts as a complete whole.
	\end{itemize}
\end{itemize}


\section{Systems}

\begin{itemize}
	
	\item Startup and runtime logic should be separated
	\item Major dependencies should be carefully considered and resolved with a consistent global strategy
	\item An option for separation, is to use main to setup and initalised before passing to run time logic
	\item Some items need to be made in an adhoc manner, these should be separate (not intwined in the logic) 
	and their creation should be abstracted away.
	  
\end{itemize}

\subsection{Kent Becks 4 rules for simple design}
\begin{itemize}
	\item Run all tests
	\item Contain no duplication
	\item Express intent of programmer
	\item Use standard design patterns to easily show intent
	\item Minimal number of classes and functions
\end{itemize}

\section{Concurrency}

\begin{itemize}
	\item Threads for I/O
	\item Processes for data sets
	
	\item Concurrency should be considered a separate issue to single thread programming 
	\item Concurrency issues arise from the large number of possible execution paths for even simple code lines
\end{itemize}

\subsection{Concurrency defense principles}

\begin{itemize}
	\item Single responsibility principle (single reason to change)
	\item Keep concurrency related code separate from other code 
  
  	\item Limit the data that might be shared
	\item Preference to use copies of data and later merge into single thread
	\item Create independent threads
  
	\item Wary of dependencies between threads
	\item Keep synchronized sections small
	\item Carefully manage graceful shutdown
	\item Tests have potential to expose problems, run them frequently with different configurations and dont ignore errors as one offs.
  
	\item Tests single threaded functions first
\end{itemize}

\subsection{Concurrent execution models}

\textbf{Producer consumer}
\begin{itemize}
	\item Queue, with some threads writing to it and others reading		
\end{itemize}

\textbf{Readers writers}
\begin{itemize}
	\item Writers wait until all readers are done. Kill off readers if they are running for too long.
\end{itemize}

\textbf{Dining philosophers}
\begin{itemize}
	\item Only act when required and there is enough capacity
\end{itemize}

%----------------------------------------------------------------------------------------
%	FIGURE EXAMPLE
%----------------------------------------------------------------------------------------

% \begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
% 	\centering
% 	\includegraphics[width=0.5\columnwidth]{IMAGE_NAME.jpg} % Example image
% 	\caption{European swallow.}
% \end{figure}

%----------------------------------------------------------------------------------------
% MATH EXAMPLES
%----------------------------------------------------------------------------------------

% \begin{align} 
% 	\label{eq:bayes}
% 	\begin{split}
% 		P(A|B) = \frac{P(B|A)P(A)}{P(B)}
% 	\end{split}					
% \end{align}

%----------------------------------------------------------------------------------------
%	LIST EXAMPLES
%----------------------------------------------------------------------------------------

% \begin{itemize}
% 	\item First item in a list 
% 		\begin{itemize}
% 		\item First item in a list 
% 			\begin{itemize}
% 			\item First item in a list 
% 			\item Second item in a list 
% 			\end{itemize}
% 		\item Second item in a list 
% 		\end{itemize}
% 	\item Second item in a list 
% \end{itemize}

%------------------------------------------------

% \subsection{Numbered List}

% \begin{enumerate}
% 	\item First item in a list 
% 	\item Second item in a list 
% 	\item Third item in a list
% \end{enumerate}

%----------------------------------------------------------------------------------------
%	TABLE EXAMPLE
%----------------------------------------------------------------------------------------

% \section{Interpreting a Table}

% \begin{table}[h] % [h] forces the table to be output where it is defined in the code (it suppresses floating)
% 	\centering % Centre the table
% 	\begin{tabular}{l l l}
% 		\toprule
% 		\textit{Per 50g} & \textbf{Pork} & \textbf{Soy} \\
% 		\midrule
% 		Energy & 760kJ & 538kJ\\
% 		Protein & 7.0g & 9.3g\\
% 		\bottomrule
% 	\end{tabular}
% 	\caption{Sausage nutrition.}
% \end{table}

%----------------------------------------------------------------------------------------
%	CODE LISTING EXAMPLE
%----------------------------------------------------------------------------------------

% \lstinputlisting[
% 	caption=Luftballons Perl Script., % Caption above the listing
% 	label=lst:luftballons, % Label for referencing this listing
% 	language=Perl, % Use Perl functions/syntax highlighting
% 	frame=single, % Frame around the code listing
% 	showstringspaces=false, % Don't put marks in string spaces
% 	numbers=left, % Line numbers on left
% 	numberstyle=\tiny, % Line numbers styling
% 	]{luftballons.pl}

%------------------------------------------------

\end{document}