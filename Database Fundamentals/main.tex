% Mo Jabeen Template for docs 

\documentclass[11pt]{scrartcl} % Font size

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{	
	\normalfont\normalsize
	\vspace{20pt} % Whitespace
	{\huge Database Fundamentals}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
}

\author{\small Mo D Jabeen} % Your name

\date{\normalsize\today} % Today's date (\today) or a custom date

\begin{document}

\maketitle % Print the title

\section{Evolution of database design}

\subsection{What has triggered the evolution in database?}

\begin{itemize}
	\item Business need to be agile, hypothesis/business models need to be tested fast and then
	decisions made if a pivot is required. Market insights should allow for quick changes to products/operations.
	\item CPU improvement is decelerating, and parallelism is increasing
\end{itemize}

\subsection{What is data intensive application?}

A data intensive application primary challenge is the use of data (storage, transformation, transmission etc)
this is primary bottle neck whereas in compute intensive apps CPU cycles is the bottle neck.

\section{Fundamental metrics}

\textbf{Reliability:} Tolerate hardware,software and human faults.\\

Fault and failure are different.

\begin{itemize}
	\item Fault: Deviates from specification
	\item Failure: Where the system stops working
\end{itemize}

Better to build fault tolerant systems that don't lead to failure. Occasionally (ie system security)
better to be fault preventive.

Worth creating faults as a testing methodology and questioning any assumptions the code bases uses to
run successfully. Systematic faults are often caused by code assumptions which are true most of the 
time. 

\subsubsection{How do you prevent human error?}

\begin{itemize}
	\item Allow fast roll backs to default configs
	\item Allow for data to be recomputed
	\item Setup good telemetry (monitoring of system health)
\end{itemize}

\textbf{Scalability:} Maintain load and performance as quantities increase.\\

\subsubsection{How do you determine the focus on when increasing scalability?}

Initial focus should be on determine the most intrinsic load parameter to the current architecture 
(ie database size, size of average reads etc).

Then question what is the effect on performance given the current resources as the load parameter is increased OR
how would the resources have to be changed.

\subsubsection{How do you measure performance?}

The most releavant performance metric should be determined (ie throughput, response time latency.) \\

This metric will most likely have a distribution even given local consistency due to external factors. The mean of this
value should generally be ignored as it does not represent an actual value experienced by the system. Instead the
median is an effective tool and the use of percentiles (50th,95th,99th etc).

\subsubsection{How to scale?}

Common knowledge is to scale on a single node before moving to a multi node setup as it is simpler. This is until it
is worth the cost of the change. Better to focus on the ability to iterate quickly than scaling for a unknown future
load.

\textbf{Maintainability:} Operability, simplicity and evolvability. (Ease of understanding).\\

The majority costs of software is upkeep not development. There are three main elements:

\begin{itemize}
	\item \textbf{Operability:} Easy to operate
	\item \textbf{Simplicity:} Easy to understand
	\item \textbf{Evolvability:} Easy to change
\end{itemize}

\subsubsection{How do you enable good operation?}

\begin{itemize}
	\item Good monitoring
	\item Standard tools
	\item Good documentation
	\item Predictable behavior
	\item Avoid single machine dependency
	\item Good default behavior
\end{itemize}

\textbf{Accidental complexity:} Arises from complexity of the implementation and is not inherent in the problem being
solved.

\section{Database Systems}

\subsection{What are some elements of a database system?}

\begin{itemize}
	\item Cache - Results of expensive operations
	\item Stream processing - Asynchronous processes messaging
	\item Batch processing - Crunch a large amount of accumulated data
	\item Message queue - Hold data for use with other processes
\end{itemize}

\subsection{Which tool should you use?}

No single tools fits all applications, instead the work should be broken into tasks
and then the most appropriate/effective tool used. 

\textit{Example: Caching - Memcached}

\section{Internal vs External}

\subsection{In code data structures}

Data structures in code are should be structured and used differently to external databases. In code
data ie for OOP should be based around their use in logic. Databases can be used by multiple separate
processes whereas data structs should only be used by local code.\\

Data structs should:

\begin{itemize}
	\item Be limited in size
	\item Not generally used for concurrent programs
	\item Not tied to ACID (Atomic,consistent,isolated and durable)
	\item Fast
\end{itemize}

\section{Data Representation}

Data representation is crucial as it will directly influence how a problem is solved. The choice of method of storage is
key:

\begin{itemize}
	\item JSON
	\item XML
	\item relational db
	\item graph models
\end{itemize}

The most popular current db model is SQL, which is based on using relational databases via relational database management
systems.

NoSQL was born from:
\begin{itemize}
	\item Need for greater scalability with a large writing throughput
	\item Desire for more dynamic and expressive data modelling (schemas can be static)
\end{itemize}

\subsection{How to handle many to one relationships?}

\begin{enumerate}
	\item Ref to another table with a foreign key
	\item XML or json to have multiple entries per row
	\item Refer to a XML or JSON doc in the entry
\end{enumerate}

In relational dbs can use \textbf{joins} to combine related data, however more difficult to handle with document or NoSQL dbs.
As an apps features grows more data is collected with key links to old data increasing the \textbf{many to many relationship issue.}\\

\textit{The key issue is to solve the many to many relationship without duplication (lacking normalisation)}

\subsection{What are document databases good for ?}

The data is normally stored in one continous string, so if all the data is loaded into the app at onces, have great locality. However normally recommended to separate docs
as if any changes are needed to that cause the file size to change the entire file will be rewritten.\\

Have a very flexible schema, allowing the use of heterogenous data ie 

\begin{itemize}
	\item Each object requires a different table
	\item Data is from external sources and its format may change
\end{itemize}

Not so good at dealing with many to one or many to many relationships.

\subsection{Declarative or imperative lang?}

SQL is declarative, the compiler will decide how to implement the requirements. An imperative lang dedicates how to perform
the requirements of the code (ie the sequence the code is executed).

\subsubsection{Why is declarative useful ?}

Good at abstracting away the db implementation, allowing the RDBM to optimize without needing to changing queries. Also
great for parallel computing.

\subsubsection{How can you use SQL features with NoSQL?}

NoSQL is implementing methods to allow working easily with subsets of data ie map and reduce. The two different methods
are converging.

%----------------------------------------------------------------------------------------
%	FIGURE EXAMPLE
%----------------------------------------------------------------------------------------

% \begin{figure}[h] % [h] forces the figure to be output where it is defined in the code (it suppresses floating)
% 	\centering
% 	\includegraphics[width=0.5\columnwidth]{IMAGE_NAME.jpg} % Example image
% 	\caption{European swallow.}
% \end{figure}

%----------------------------------------------------------------------------------------
% MATH EXAMPLES
%----------------------------------------------------------------------------------------

% \begin{align} 
% 	\label{eq:bayes}
% 	\begin{split}
% 		P(A|B) = \frac{P(B|A)P(A)}{P(B)}
% 	\end{split}					
% \end{align}

%----------------------------------------------------------------------------------------
%	LIST EXAMPLES
%----------------------------------------------------------------------------------------

% \begin{itemize}
% 	\item First item in a list 
% 		\begin{itemize}
% 		\item First item in a list 
% 			\begin{itemize}
% 			\item First item in a list 
% 			\item Second item in a list 
% 			\end{itemize}
% 		\item Second item in a list 
% 		\end{itemize}
% 	\item Second item in a list 
% \end{itemize}

%------------------------------------------------

% \subsection{Numbered List}

% \begin{enumerate}
% 	\item First item in a list 
% 	\item Second item in a list 
% 	\item Third item in a list
% \end{enumerate}

%----------------------------------------------------------------------------------------
%	TABLE EXAMPLE
%----------------------------------------------------------------------------------------

% \section{Interpreting a Table}

% \begin{table}[h] % [h] forces the table to be output where it is defined in the code (it suppresses floating)
% 	\centering % Centre the table
% 	\begin{tabular}{l l l}
% 		\toprule
% 		\textit{Per 50g} & \textbf{Pork} & \textbf{Soy} \\
% 		\midrule
% 		Energy & 760kJ & 538kJ\\
% 		Protein & 7.0g & 9.3g\\
% 		\bottomrule
% 	\end{tabular}
% 	\caption{Sausage nutrition.}
% \end{table}

%----------------------------------------------------------------------------------------
%	CODE LISTING EXAMPLE
%----------------------------------------------------------------------------------------

% \begin{lstlisting}[
% 	caption= Macro definition, % Caption above the listing
% 	language=python, % Use Julia functions/syntax highlighting
% 	frame=single, % Frame around the code listing
% 	showstringspaces=false, % Don't put marks in string spaces
% 	numbers=left, % Line numbers on left
% 	numberstyle=\large, % Line numbers styling
% 	]

% 	CODE

% \end{lstlisting}

%----------------------------------------------------------------------------------------
%	CODE LISTING FILE EXAMPLE
%----------------------------------------------------------------------------------------

% \lstinputlisting[
% 	caption=Luftballons Perl Script., % Caption above the listing
% 	label=lst:luftballons, % Label for referencing this listing
% 	language=Perl, % Use Perl functions/syntax highlighting
% 	frame=single, % Frame around the code listing
% 	showstringspaces=false, % Don't put marks in string spaces
% 	numbers=left, % Line numbers on left
% 	numberstyle=\tiny, % Line numbers styling
% 	]{luftballons.pl}

%------------------------------------------------

\end{document}